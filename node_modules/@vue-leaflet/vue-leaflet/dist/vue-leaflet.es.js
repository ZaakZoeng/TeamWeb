import { watch as ne, ref as y, provide as T, h as I, inject as c, onUnmounted as Y, onBeforeUnmount as U, onMounted as b, markRaw as _, nextTick as f, render as Ae, reactive as we, computed as se } from "vue";
const le = (t, o = 100) => {
  let e;
  const n = function(...r) {
    const s = this;
    e && clearTimeout(e), e = setTimeout(() => {
      t.apply(s, r), e = null;
    }, o);
  };
  return n.cancel = function() {
    e && clearTimeout(e);
  }, n;
}, ie = function(t) {
  for (const o of Object.values(t))
    o && M(o.cancel) && o.cancel();
}, Ge = (t) => !t || typeof t.charAt != "function" ? t : t.charAt(0).toUpperCase() + t.slice(1), M = (t) => typeof t == "function", h = (t, o, e) => {
  for (const n in e) {
    const r = "set" + Ge(n);
    t[r] ? ne(
      () => e[n],
      (s, l) => {
        t[r](s, l);
      }
    ) : o[r] && ne(
      () => e[n],
      (s) => {
        o[r](s);
      }
    );
  }
}, L = (t, o, e = {}) => {
  const n = { ...e };
  for (const r in t) {
    const s = o[r], l = t[r];
    s && (s && s.custom === !0 || l !== void 0 && (n[r] = l));
  }
  return n;
}, S = (t) => {
  const o = {};
  for (const e in t)
    if (e.startsWith("on") && !e.startsWith("onUpdate") && e !== "onReady") {
      const n = e.slice(2).toLocaleLowerCase();
      o[n] = t[e];
    }
  return o;
}, Me = async (t) => {
  const o = await Promise.all([
    import("leaflet/dist/images/marker-icon-2x.png"),
    import("leaflet/dist/images/marker-icon.png"),
    import("leaflet/dist/images/marker-shadow.png")
  ]);
  delete t.Default.prototype._getIconUrl, t.Default.mergeOptions({
    iconRetinaUrl: o[0].default,
    iconUrl: o[1].default,
    shadowUrl: o[2].default
  });
}, q = (t) => {
  const o = y(
    () => console.warn(`Method ${t} has been invoked without being replaced`)
  ), e = (...n) => o.value(...n);
  return e.wrapped = o, T(t, e), e;
}, J = (t, o) => t.wrapped.value = o, v = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || void 0, g = "useGlobalLeaflet", z = {
  options: {
    type: Object,
    default: () => ({}),
    custom: !0
  }
}, F = (t) => ({ options: t.options, methods: {} }), k = {
  ...z,
  pane: {
    type: String
  },
  attribution: {
    type: String
  },
  name: {
    type: String,
    custom: !0
  },
  layerType: {
    type: String,
    custom: !0
  },
  visible: {
    type: Boolean,
    custom: !0,
    default: !0
  }
}, Z = (t, o, e) => {
  const n = c("addLayer"), r = c("removeLayer"), {
    options: s,
    methods: l
  } = F(t), a = L(t, k, s), i = () => n({ leafletObject: o.value }), u = () => r({ leafletObject: o.value }), p = {
    ...l,
    setAttribution(m) {
      u(), o.value.options.attribution = m, t.visible && i();
    },
    setName() {
      u(), t.visible && i();
    },
    setLayerType() {
      u(), t.visible && i();
    },
    setVisible(m) {
      o.value && (m ? i() : u());
    },
    bindPopup({ leafletObject: m }) {
      if (!o.value || !M(o.value.bindPopup)) {
        console.warn(
          "Attempt to bind popup before bindPopup method available on layer."
        );
        return;
      }
      o.value.bindPopup(m);
    },
    bindTooltip({ leafletObject: m }) {
      if (!o.value || !M(o.value.bindTooltip)) {
        console.warn(
          "Attempt to bind tooltip before bindTooltip method available on layer."
        );
        return;
      }
      o.value.bindTooltip(m);
    },
    unbindTooltip() {
      o.value && (M(o.value.closeTooltip) && o.value.closeTooltip(), M(o.value.unbindTooltip) && o.value.unbindTooltip());
    },
    unbindPopup() {
      o.value && (M(o.value.closePopup) && o.value.closePopup(), M(o.value.unbindPopup) && o.value.unbindPopup());
    },
    updateVisibleProp(m) {
      e.emit("update:visible", m);
    }
  };
  return T("bindPopup", p.bindPopup), T("bindTooltip", p.bindTooltip), T("unbindTooltip", p.unbindTooltip), T("unbindPopup", p.unbindPopup), Y(() => {
    p.unbindPopup(), p.unbindTooltip(), u();
  }), { options: a, methods: p };
}, A = (t, o) => {
  if (t && o.default)
    return I("div", { style: { display: "none" } }, o.default());
}, ue = {
  ...k,
  interactive: {
    type: Boolean,
    default: void 0
  },
  bubblingMouseEvents: {
    type: Boolean,
    default: void 0
  }
}, Ie = (t, o, e) => {
  const { options: n, methods: r } = Z(
    t,
    o,
    e
  );
  return { options: L(
    t,
    ue,
    n
  ), methods: r };
}, V = {
  ...ue,
  stroke: {
    type: Boolean,
    default: void 0
  },
  color: {
    type: String
  },
  weight: {
    type: Number
  },
  opacity: {
    type: Number
  },
  lineCap: {
    type: String
  },
  lineJoin: {
    type: String
  },
  dashArray: {
    type: String
  },
  dashOffset: {
    type: String
  },
  fill: {
    type: Boolean,
    default: void 0
  },
  fillColor: {
    type: String
  },
  fillOpacity: {
    type: Number
  },
  fillRule: {
    type: String
  },
  className: {
    type: String
  }
}, ce = (t, o, e) => {
  const {
    options: n,
    methods: r
  } = Ie(t, o, e), s = L(
    t,
    V,
    n
  ), l = c("removeLayer"), a = {
    ...r,
    setStroke(i) {
      o.value.setStyle({ stroke: i });
    },
    setColor(i) {
      o.value.setStyle({ color: i });
    },
    setWeight(i) {
      o.value.setStyle({ weight: i });
    },
    setOpacity(i) {
      o.value.setStyle({ opacity: i });
    },
    setLineCap(i) {
      o.value.setStyle({ lineCap: i });
    },
    setLineJoin(i) {
      o.value.setStyle({ lineJoin: i });
    },
    setDashArray(i) {
      o.value.setStyle({ dashArray: i });
    },
    setDashOffset(i) {
      o.value.setStyle({ dashOffset: i });
    },
    setFill(i) {
      o.value.setStyle({ fill: i });
    },
    setFillColor(i) {
      o.value.setStyle({ fillColor: i });
    },
    setFillOpacity(i) {
      o.value.setStyle({ fillOpacity: i });
    },
    setFillRule(i) {
      o.value.setStyle({ fillRule: i });
    },
    setClassName(i) {
      o.value.setStyle({ className: i });
    }
  };
  return U(() => {
    l({ leafletObject: o.value });
  }), { options: s, methods: a };
}, x = {
  ...V,
  /**
   * Radius of the marker in pixels.
   */
  radius: {
    type: Number
  },
  latLng: {
    type: [Object, Array],
    required: !0,
    custom: !0
  }
}, de = (t, o, e) => {
  const { options: n, methods: r } = ce(
    t,
    o,
    e
  ), s = L(t, x, n), l = {
    ...r,
    setRadius(a) {
      o.value.setRadius(a);
    },
    setLatLng(a) {
      o.value.setLatLng(a);
    }
  };
  return { options: s, methods: l };
}, pe = {
  ...x,
  /**
   * Radius of the circle in meters.
   */
  radius: {
    type: Number
  }
}, Ne = (t, o, e) => {
  const {
    options: n,
    methods: r
  } = de(t, o, e), s = L(
    t,
    pe,
    n
  ), l = {
    ...r
  };
  return { options: s, methods: l };
}, ke = {
  name: "LCircle",
  props: pe,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = Ne(t, e, o);
    return b(async () => {
      const { circle: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(t.latLng, l));
      const p = S(o.attrs);
      u.on(e.value, p), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, jt = ke, De = {
  name: "LCircleMarker",
  props: x,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = de(
      t,
      e,
      o
    );
    return b(async () => {
      const { circleMarker: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(t.latLng, l));
      const p = S(o.attrs);
      u.on(e.value, p), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Pt = De, D = {
  ...z,
  position: {
    type: String
  }
}, W = (t, o) => {
  const {
    options: e,
    methods: n
  } = F(t), r = L(t, D, e), s = {
    ...n,
    setPosition(l) {
      o.value && o.value.setPosition(l);
    }
  };
  return Y(() => {
    o.value && o.value.remove();
  }), { options: r, methods: s };
}, Ee = (t) => t.default ? I("div", { ref: "root" }, t.default()) : null, He = {
  name: "LControl",
  props: {
    ...D,
    disableClickPropagation: {
      type: Boolean,
      custom: !0,
      default: !0
    },
    disableScrollPropagation: {
      type: Boolean,
      custom: !0,
      default: !1
    }
  },
  setup(t, o) {
    const e = y({}), n = y(null), r = c(g), s = c("registerControl"), { options: l, methods: a } = W(t, e);
    return b(async () => {
      const { Control: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm"), p = i.extend({
        onAdd() {
          return n.value;
        }
      });
      e.value = _(new p(l)), h(a, e.value, t), s({ leafletObject: e.value }), t.disableClickPropagation && u.disableClickPropagation(n.value), t.disableScrollPropagation && u.disableScrollPropagation(n.value), f(() => o.emit("ready", e.value));
    }), { root: n, leafletObject: e };
  },
  render() {
    return Ee(this.$slots);
  }
}, Bt = He, ye = {
  ...D,
  prefix: {
    type: String
  }
}, Ue = (t, o) => {
  const { options: e, methods: n } = W(
    t,
    o
  ), r = L(
    t,
    ye,
    e
  ), s = {
    ...n,
    setPrefix(l) {
      o.value.setPrefix(l);
    }
  };
  return { options: r, methods: s };
}, ze = {
  name: "LControlAttribution",
  props: ye,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("registerControl"), { options: s, methods: l } = Ue(t, e);
    return b(async () => {
      const { control: a } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a.attribution(s)), h(l, e.value, t), r({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, Tt = ze, me = {
  ...D,
  collapsed: {
    type: Boolean,
    default: void 0
  },
  autoZIndex: {
    type: Boolean,
    default: void 0
  },
  hideSingleBase: {
    type: Boolean,
    default: void 0
  },
  sortLayers: {
    type: Boolean,
    default: void 0
  },
  sortFunction: {
    type: Function
  }
}, Fe = (t, o) => {
  const { options: e } = W(t, o);
  return { options: L(
    t,
    me,
    e
  ), methods: {
    addLayer(s) {
      s.layerType === "base" ? o.value.addBaseLayer(s.leafletObject, s.name) : s.layerType === "overlay" && o.value.addOverlay(s.leafletObject, s.name);
    },
    removeLayer(s) {
      o.value.removeLayer(s.leafletObject);
    }
  } };
}, Ze = {
  name: "LControlLayers",
  props: me,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("registerLayerControl"), { options: s, methods: l } = Fe(t, e);
    return b(async () => {
      const { control: a } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a.layers(null, null, s)), h(l, e.value, t), r({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, $t = Ze, ve = {
  ...D,
  maxWidth: {
    type: Number
  },
  metric: {
    type: Boolean,
    default: void 0
  },
  imperial: {
    type: Boolean,
    default: void 0
  },
  updateWhenIdle: {
    type: Boolean,
    default: void 0
  }
}, We = (t, o) => {
  const { options: e, methods: n } = W(
    t,
    o
  );
  return { options: L(
    t,
    ve,
    e
  ), methods: n };
}, qe = {
  name: "LControlScale",
  props: ve,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("registerControl"), { options: s, methods: l } = We(t, e);
    return b(async () => {
      const { control: a } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a.scale(s)), h(l, e.value, t), r({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, At = qe, fe = {
  ...D,
  zoomInText: {
    type: String
  },
  zoomInTitle: {
    type: String
  },
  zoomOutText: {
    type: String
  },
  zoomOutTitle: {
    type: String
  }
}, Je = (t, o) => {
  const { options: e, methods: n } = W(
    t,
    o
  );
  return { options: L(
    t,
    fe,
    e
  ), methods: n };
}, Ke = {
  name: "LControlZoom",
  props: fe,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("registerControl"), { options: s, methods: l } = Je(t, e);
    return b(async () => {
      const { control: a } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a.zoom(s)), h(l, e.value, t), r({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, wt = Ke, K = {
  ...k
}, R = (t, o, e) => {
  const { options: n, methods: r } = Z(
    t,
    o,
    e
  ), s = L(t, K, n), l = {
    ...r,
    addLayer(a) {
      o.value.addLayer(a.leafletObject);
    },
    removeLayer(a) {
      o.value.removeLayer(a.leafletObject);
    }
  };
  return T("addLayer", l.addLayer), T("removeLayer", l.removeLayer), { options: s, methods: l };
}, Le = {
  ...K
}, Qe = (t, o) => {
  const { options: e, methods: n } = R(
    t,
    o
  ), r = L(t, Le, e), s = {
    ...n
  };
  return { options: r, methods: s };
}, Xe = {
  props: Le,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { methods: l, options: a } = Qe(t, e);
    return b(async () => {
      const { featureGroup: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(a));
      const p = S(o.attrs);
      u.on(e.value, p), h(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Gt = Xe, be = {
  ...K,
  geojson: {
    type: [Object, Array],
    custom: !0
  },
  optionsStyle: {
    type: [Object, Function],
    custom: !0
  }
}, Ye = (t, o, e) => {
  const { options: n, methods: r } = R(
    t,
    o,
    e
  ), s = L(t, be, n);
  Object.prototype.hasOwnProperty.call(t, "optionsStyle") && (s.style = t.optionsStyle);
  const l = {
    ...r,
    setGeojson(a) {
      o.value.clearLayers(), o.value.addData(a);
    },
    setOptionsStyle(a) {
      o.value.setStyle(a);
    },
    getGeoJSONData() {
      return o.value.toGeoJSON();
    },
    getBounds() {
      return o.value.getBounds();
    }
  };
  return { options: s, methods: l };
}, Ve = {
  props: be,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { methods: l, options: a } = Ye(t, e, o);
    return b(async () => {
      const { geoJSON: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(t.geojson, a));
      const p = S(o.attrs);
      u.on(e.value, p), h(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Mt = Ve, ee = {
  ...k,
  opacity: {
    type: Number
  },
  zIndex: {
    type: Number
  },
  tileSize: {
    type: Number
  },
  noWrap: {
    type: Boolean,
    default: void 0
  },
  minZoom: {
    type: Number
  },
  maxZoom: {
    type: Number
  }
}, he = (t, o, e) => {
  const { options: n, methods: r } = Z(
    t,
    o,
    e
  );
  return { options: L(t, ee, n), methods: { ...r } };
}, xe = {
  props: {
    ...ee,
    childRender: {
      type: Function,
      required: !0
    }
  },
  setup(t, o) {
    const e = y({}), n = y({}), r = y(null), s = y(!1), l = c(g), a = c("addLayer"), { options: i, methods: u } = he(t, e, o);
    return b(async () => {
      const { GridLayer: p, DomEvent: m, DomUtil: $ } = l ? v.L : await import("leaflet/dist/leaflet-src.esm");
      u.onUnload = (B) => {
        const j = e.value._tileCoordsToKey(B.coords);
        n[j] && (n[j].innerHTML = "", n[j] = void 0);
      }, u.setTileComponent = () => {
        e.value.redraw();
      };
      const O = p.extend({
        createTile(B) {
          const j = e.value._tileCoordsToKey(B);
          n[j] = $.create("div");
          let G = I(
            { setup: t.childRender, props: ["coords"] },
            { coords: B }
          );
          return Ae(G, n[j]), n[j];
        }
      });
      e.value = _(new O(i));
      const P = S(o.attrs);
      m.on(e.value, P), e.value.on("tileunload", u.onUnload), h(u, e.value, t), a({
        ...t,
        ...u,
        leafletObject: e.value
      }), s.value = !0, f(() => o.emit("ready", e.value));
    }), Y(() => {
      e.value.off("tileunload", u.onUnload);
    }), { root: r, ready: s, leafletObject: e };
  },
  render() {
    return this.ready ? I("div", { style: { display: "none" }, ref: "root" }) : null;
  }
}, It = xe, ae = {
  iconUrl: {
    type: String
  },
  iconRetinaUrl: {
    type: String
  },
  iconSize: {
    type: [Object, Array]
  },
  iconAnchor: {
    type: [Object, Array]
  },
  popupAnchor: {
    type: [Object, Array]
  },
  tooltipAnchor: {
    type: [Object, Array]
  },
  shadowUrl: {
    type: String
  },
  shadowRetinaUrl: {
    type: String
  },
  shadowSize: {
    type: [Object, Array]
  },
  shadowAnchor: {
    type: [Object, Array]
  },
  bgPos: {
    type: [Object, Array]
  },
  className: {
    type: String
  }
}, Re = {
  name: "LIcon",
  props: {
    ...ae,
    ...z
  },
  setup(t, o) {
    const e = y(null), n = c(g), r = c("canSetParentHtml"), s = c("setParentHtml"), l = c("setIcon");
    let a, i, u, p, m;
    const $ = (j, G, E) => {
      const N = j && j.innerHTML;
      if (!G) {
        E && m && r() && s(N);
        return;
      }
      const w = S(o.attrs);
      m && i(m, w);
      const { options: X } = F(t), d = L(t, ae, X);
      N && (d.html = N), m = d.html ? u(d) : p(d), a(m, w), l(m);
    }, O = () => {
      f(() => $(e.value, !0, !1));
    }, P = () => {
      f(() => $(e.value, !1, !0));
    }, B = {
      setIconUrl: O,
      setIconRetinaUrl: O,
      setIconSize: O,
      setIconAnchor: O,
      setPopupAnchor: O,
      setTooltipAnchor: O,
      setShadowUrl: O,
      setShadowRetinaUrl: O,
      setShadowAnchor: O,
      setBgPos: O,
      setClassName: O,
      setHtml: O
    };
    return b(async () => {
      const { DomEvent: j, divIcon: G, icon: E } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      a = j.on, i = j.off, u = G, p = E, h(B, {}, t), new MutationObserver(P).observe(e.value, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      }), O();
    }), { root: e };
  },
  render() {
    const t = this.$slots.default ? this.$slots.default() : void 0;
    return I("div", { ref: "root" }, t);
  }
}, Nt = Re, ge = {
  ...k,
  opacity: {
    type: Number
  },
  alt: {
    type: String
  },
  interactive: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: {
    type: Boolean,
    default: void 0
  },
  errorOverlayUrl: {
    type: String
  },
  zIndex: {
    type: Number
  },
  className: {
    type: String
  },
  url: {
    type: String,
    required: !0,
    custom: !0
  },
  bounds: {
    type: [Array, Object],
    required: !0,
    custom: !0
  }
}, et = (t, o, e) => {
  const { options: n, methods: r } = Z(
    t,
    o,
    e
  ), s = L(t, ge, n), l = {
    ...r,
    /**
     * Sets the opacity of the overlay.
     * @param {number} opacity
     */
    setOpacity(a) {
      return o.value.setOpacity(a);
    },
    /**
     * Changes the URL of the image.
     * @param {string} url
     */
    setUrl(a) {
      return o.value.setUrl(a);
    },
    /**
     * Update the bounds that this ImageOverlay covers
     * @param {LatLngBounds | Array<Array<number>>} bounds
     */
    setBounds(a) {
      return o.value.setBounds(a);
    },
    /**
     * Get the bounds that this ImageOverlay covers
     * @returns {LatLngBounds}
     */
    getBounds() {
      return o.value.getBounds();
    },
    /**
     * Returns the instance of HTMLImageElement used by this overlay.
     * @returns {HTMLElement}
     */
    getElement() {
      return o.value.getElement();
    },
    /**
     * Brings the layer to the top of all overlays.
     */
    bringToFront() {
      return o.value.bringToFront();
    },
    /**
     * Brings the layer to the bottom of all overlays.
     */
    bringToBack() {
      return o.value.bringToBack();
    },
    /**
     * Changes the zIndex of the image overlay.
     * @param {number} zIndex
     */
    setZIndex(a) {
      return o.value.setZIndex(a);
    }
  };
  return { options: s, methods: l };
}, tt = {
  name: "LImageOverlay",
  props: ge,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = et(
      t,
      e,
      o
    );
    return b(async () => {
      const { imageOverlay: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(
        i(t.url, t.bounds, l)
      );
      const p = S(o.attrs);
      u.on(e.value, p), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, kt = tt, ot = {
  props: K,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { methods: l } = R(t, e, o);
    return b(async () => {
      const { layerGroup: a, DomEvent: i } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a(t.options));
      const u = S(o.attrs);
      i.on(e.value, u), h(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Dt = ot, re = {
  ...z,
  /**
   * The center of the map, supports .sync modifier
   */
  center: {
    type: [Object, Array]
  },
  /**
   * The bounds of the map, supports .sync modifier
   */
  bounds: {
    type: [Array, Object]
  },
  /**
   * The max bounds of the map
   */
  maxBounds: {
    type: [Array, Object]
  },
  /**
   * The zoom of the map, supports .sync modifier
   */
  zoom: {
    type: Number
  },
  /**
   * The minZoom of the map
   */
  minZoom: {
    type: Number
  },
  /**
   * The maxZoom of the map
   */
  maxZoom: {
    type: Number
  },
  /**
   * The paddingBottomRight of the map
   */
  paddingBottomRight: {
    type: Array
  },
  /**
   * The paddingTopLeft of the map
   */
  paddingTopLeft: {
    type: Array
  },
  /**
   * The padding of the map
   */
  padding: {
    type: Array
  },
  /**
   * The worldCopyJump option for the map
   */
  worldCopyJump: {
    type: Boolean,
    default: void 0
  },
  /**
   * The CRS to use for the map. Can be an object that defines a coordinate reference
   * system for projecting geographical points into screen coordinates and back
   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string
   * name identifying one of Leaflet's defined CRSs, such as "EPSG4326".
   */
  crs: {
    type: [String, Object]
  },
  maxBoundsViscosity: {
    type: Number
  },
  inertia: {
    type: Boolean,
    default: void 0
  },
  inertiaDeceleration: {
    type: Number
  },
  inertiaMaxSpeed: {
    type: Number
  },
  easeLinearity: {
    type: Number
  },
  zoomAnimation: {
    type: Boolean,
    default: void 0
  },
  zoomAnimationThreshold: {
    type: Number
  },
  fadeAnimation: {
    type: Boolean,
    default: void 0
  },
  markerZoomAnimation: {
    type: Boolean,
    default: void 0
  },
  noBlockingAnimations: {
    type: Boolean,
    default: void 0
  },
  useGlobalLeaflet: {
    type: Boolean,
    default: !0,
    custom: !0
  }
}, nt = {
  emits: ["ready", "update:zoom", "update:center", "update:bounds"],
  props: re,
  setup(t, o) {
    const e = y(null), n = we({
      ready: !1,
      leafletRef: {},
      layersToAdd: [],
      layersInControl: []
    }), { options: r } = F(t), s = L(t, re, r), l = q("addLayer"), a = q("removeLayer"), i = q("registerControl"), u = q("registerLayerControl");
    T(g, t.useGlobalLeaflet);
    const p = {
      moveEndHandler: le(() => {
        o.emit("update:zoom", n.leafletRef.getZoom()), o.emit("update:center", n.leafletRef.getCenter()), o.emit("update:bounds", n.leafletRef.getBounds());
      }),
      overlayAddHandler(O) {
        const P = n.layersInControl.find((B) => B.name === O.name);
        P && P.updateVisibleProp(!0);
      },
      overlayRemoveHandler(O) {
        const P = n.layersInControl.find((B) => B.name === O.name);
        P && P.updateVisibleProp(!1);
      }
    };
    b(async () => {
      t.useGlobalLeaflet && (v.L = v.L || await import("leaflet"));
      const {
        map: O,
        CRS: P,
        Icon: B,
        latLngBounds: j,
        latLng: G,
        DomEvent: E
      } = t.useGlobalLeaflet ? v.L : await import("leaflet/dist/leaflet-src.esm");
      try {
        s.beforeMapMount && await s.beforeMapMount();
      } catch (d) {
        console.error(
          `The following error occurred running the provided beforeMapMount hook ${d.message}`
        );
      }
      await Me(B);
      const N = typeof s.crs == "string" ? P[s.crs] : s.crs;
      s.crs = N || P.EPSG3857;
      const w = {
        addLayer(d) {
          d.layerType !== void 0 && (n.layerControl === void 0 ? n.layersToAdd.push(d) : n.layersInControl.find(
            (H) => H.leafletObject._leaflet_id === d.leafletObject._leaflet_id
          ) || (n.layerControl.addLayer(d), n.layersInControl.push(d))), d.visible !== !1 && n.leafletRef.addLayer(d.leafletObject);
        },
        removeLayer(d) {
          d.layerType !== void 0 && (n.layerControl === void 0 ? n.layersToAdd = n.layersToAdd.filter(
            (C) => C.name !== d.name
          ) : (n.layerControl.removeLayer(d.leafletObject), n.layersInControl = n.layersInControl.filter(
            (C) => C.leafletObject._leaflet_id !== d.leafletObject._leaflet_id
          ))), n.leafletRef.removeLayer(d.leafletObject);
        },
        registerLayerControl(d) {
          n.layerControl = d, n.layersToAdd.forEach((C) => {
            n.layerControl.addLayer(C);
          }), n.layersToAdd = [], i(d);
        },
        registerControl(d) {
          n.leafletRef.addControl(d.leafletObject);
        },
        setZoom(d) {
          const C = n.leafletRef.getZoom();
          d !== C && n.leafletRef.setZoom(d, {
            animate: t.noBlockingAnimations ? !1 : null
          });
        },
        setPaddingBottomRight(d) {
          n.paddingBottomRight = d;
        },
        setPaddingTopLeft(d) {
          n.paddingTopLeft = d;
        },
        setPadding(d) {
          n.padding = d;
        },
        setCrs(d) {
          const C = n.leafletRef.getBounds();
          n.leafletRef.options.crs = d, n.leafletRef.fitBounds(C, {
            animate: !1,
            padding: [0, 0]
          });
        },
        fitBounds(d) {
          n.leafletRef.fitBounds(d, {
            animate: this.noBlockingAnimations ? !1 : null
          });
        },
        setBounds(d) {
          if (!d)
            return;
          const C = j(d);
          if (!C.isValid())
            return;
          !(n.lastSetBounds || n.leafletRef.getBounds()).equals(C, 0) && (n.lastSetBounds = C, n.leafletRef.fitBounds(C, this.fitBoundsOptions));
        },
        setCenter(d) {
          if (d == null)
            return;
          const C = G(d), H = n.lastSetCenter || n.leafletRef.getCenter();
          (H.lat !== C.lat || H.lng !== C.lng) && (n.lastSetCenter = C, n.leafletRef.panTo(C, {
            animate: this.noBlockingAnimations ? !1 : null
          }));
        }
      };
      J(l, w.addLayer), J(a, w.removeLayer), J(i, w.registerControl), J(u, w.registerLayerControl), n.leafletRef = _(O(e.value, s)), h(w, n.leafletRef, t);
      const X = S(o.attrs);
      n.leafletRef.on("moveend", p.moveEndHandler), n.leafletRef.on("overlayadd", p.overlayAddHandler), n.leafletRef.on(
        "overlayremove",
        p.overlayRemoveHandler
      ), E.on(n.leafletRef, X), n.ready = !0, f(() => o.emit("ready", n.leafletRef));
    }), U(() => {
      ie(p), n.leafletRef && (n.leafletRef.off(), n.leafletRef.remove());
    });
    const m = se(() => n.leafletRef), $ = se(() => n.ready);
    return { root: e, ready: $, leafletObject: m };
  },
  render() {
    return I(
      "div",
      { style: { width: "100%", height: "100%" }, ref: "root" },
      this.ready && this.$slots.default ? this.$slots.default() : {}
    );
  }
}, Et = nt, st = ["Symbol(Comment)", "Symbol(Text)"], at = ["LTooltip", "LPopup"], Oe = {
  ...k,
  draggable: {
    type: Boolean,
    default: void 0
  },
  icon: {
    type: [Object]
  },
  zIndexOffset: {
    type: Number
  },
  latLng: {
    type: [Object, Array],
    custom: !0,
    required: !0
  }
}, rt = (t, o, e) => {
  const { options: n, methods: r } = Z(
    t,
    o,
    e
  ), s = L(t, Oe, n), l = {
    ...r,
    setDraggable(a) {
      o.value.dragging && (a ? o.value.dragging.enable() : o.value.dragging.disable());
    },
    latLngSync(a) {
      e.emit("update:latLng", a.latlng), e.emit("update:lat-lng", a.latlng);
    },
    setLatLng(a) {
      if (a != null && o.value) {
        const i = o.value.getLatLng();
        (!i || !i.equals(a)) && o.value.setLatLng(a);
      }
    }
  };
  return { options: s, methods: l };
}, lt = (t, o) => {
  const e = o.slots.default && o.slots.default();
  return e && e.length && e.some(it);
};
function it(t) {
  return !(st.includes(t.type.toString()) || at.includes(t.type.name));
}
const ut = {
  name: "LMarker",
  props: Oe,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer");
    T("canSetParentHtml", () => !!e.value.getElement()), T(
      "setParentHtml",
      (u) => e.value.getElement().innerHTML = u
    ), T(
      "setIcon",
      (u) => e.value.setIcon && e.value.setIcon(u)
    );
    const { options: l, methods: a } = rt(t, e, o), i = {
      moveHandler: le(a.latLngSync)
    };
    return b(async () => {
      const { marker: u, DomEvent: p, divIcon: m } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      lt(l, o) && (l.icon = m({ className: "" })), e.value = _(u(t.latLng, l));
      const $ = S(o.attrs);
      p.on(e.value, $), e.value.on("move", i.moveHandler), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), U(() => ie(i)), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Ht = ut, te = {
  ...V,
  smoothFactor: {
    type: Number
  },
  noClip: {
    type: Boolean,
    default: void 0
  },
  latLngs: {
    type: Array,
    required: !0,
    custom: !0
  }
}, _e = (t, o, e) => {
  const { options: n, methods: r } = ce(
    t,
    o,
    e
  ), s = L(t, te, n), l = {
    ...r,
    setSmoothFactor(a) {
      o.value.setStyle({ smoothFactor: a });
    },
    setNoClip(a) {
      o.value.setStyle({ noClip: a });
    },
    addLatLng(a) {
      o.value.addLatLng(a);
    }
  };
  return { options: s, methods: l };
}, Q = {
  ...te
}, Ce = (t, o, e) => {
  const { options: n, methods: r } = _e(
    t,
    o,
    e
  ), s = L(t, Q, n), l = {
    ...r,
    toGeoJSON(a) {
      return o.value.toGeoJSON(a);
    }
  };
  return { options: s, methods: l };
}, ct = {
  name: "LPolygon",
  props: Q,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = Ce(t, e, o);
    return b(async () => {
      const { polygon: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(t.latLngs, l));
      const p = S(o.attrs);
      u.on(e.value, p), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Ut = ct, dt = {
  name: "LPolyline",
  props: te,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = _e(t, e, o);
    return b(async () => {
      const { polyline: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(t.latLngs, l));
      const p = S(o.attrs);
      u.on(e.value, p), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, zt = dt, Se = {
  ...z,
  content: {
    type: String,
    default: null
  }
}, je = (t, o) => {
  const { options: e, methods: n } = F(t), r = {
    ...n,
    setContent(s) {
      o.value && s !== null && s !== void 0 && o.value.setContent(s);
    }
  };
  return { options: e, methods: r };
}, Pe = (t) => t.default ? I("div", { ref: "root" }, t.default()) : null, pt = {
  ...Se,
  latLng: {
    type: [Object, Array],
    default: () => []
  }
}, yt = (t, o) => {
  const { options: e, methods: n } = je(t, o);
  return { options: e, methods: n };
}, mt = {
  name: "LPopup",
  props: pt,
  setup(t, o) {
    const e = y({}), n = y(null), r = c(g), s = c("bindPopup"), l = c("unbindPopup"), { options: a, methods: i } = yt(t, e);
    return b(async () => {
      const { popup: u, DomEvent: p } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(u(a)), t.latLng !== void 0 && e.value.setLatLng(t.latLng), h(i, e.value, t);
      const m = S(o.attrs);
      p.on(e.value, m), e.value.setContent(t.content || n.value), s({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), U(() => {
      l({ leafletObject: e.value });
    }), { root: n, leafletObject: e };
  },
  render() {
    return Pe(this.$slots);
  }
}, Ft = mt;
Q.latLngs.required = !1;
const Be = {
  ...Q,
  bounds: {
    type: Array,
    custom: !0
  }
}, vt = (t, o, e) => {
  const { options: n, methods: r } = Ce(
    t,
    o,
    e
  ), s = L(t, Be, n), l = {
    ...r,
    setBounds(a) {
      o.value.setBounds(a);
    },
    setLatLngs(a) {
      o.value.setBounds(a);
    }
  };
  return { options: s, methods: l };
}, ft = {
  name: "LRectangle",
  props: Be,
  setup(t, o) {
    const e = y({}), n = y(!1), r = c(g), s = c("addLayer"), { options: l, methods: a } = vt(t, e, o);
    return b(async () => {
      const { rectangle: i, latLngBounds: u, DomEvent: p } = r ? v.L : await import("leaflet/dist/leaflet-src.esm"), m = t.bounds && t.bounds.length ? u(t.bounds) : u(t.latLngs);
      e.value = _(i(m, l));
      const $ = S(o.attrs);
      p.on(e.value, $), h(a, e.value, t), s({
        ...t,
        ...a,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return A(this.ready, this.$slots);
  }
}, Zt = ft, oe = {
  ...ee,
  tms: {
    type: Boolean,
    default: void 0
  },
  subdomains: {
    type: [String, Array],
    validator: (t) => typeof t == "string" ? !0 : Array.isArray(t) ? t.every((o) => typeof o == "string") : !1
  },
  detectRetina: {
    type: Boolean,
    default: void 0
  },
  url: {
    type: String,
    required: !0,
    custom: !0
  }
}, Te = (t, o, e) => {
  const {
    options: n,
    methods: r
  } = he(t, o, e), s = L(
    t,
    oe,
    n
  ), l = {
    ...r
  };
  return { options: s, methods: l };
}, Lt = {
  props: oe,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("addLayer"), { options: s, methods: l } = Te(t, e, o);
    return b(async () => {
      const { tileLayer: a, DomEvent: i } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a(t.url, s));
      const u = S(o.attrs);
      i.on(e.value, u), h(l, e.value, t), r({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, Wt = Lt, bt = {
  ...Se
}, ht = (t, o) => {
  const { options: e, methods: n } = je(t, o), r = c("unbindTooltip");
  return U(() => {
    r();
  }), { options: e, methods: n };
}, gt = {
  name: "LTooltip",
  props: bt,
  setup(t, o) {
    const e = y({}), n = y(null), r = c(g), s = c("bindTooltip"), { options: l, methods: a } = ht(t, e);
    return b(async () => {
      const { tooltip: i, DomEvent: u } = r ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(i(l)), h(a, e.value, t);
      const p = S(o.attrs);
      u.on(e.value, p), e.value.setContent(t.content || n.value), s({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { root: n, leafletObject: e };
  },
  render() {
    return Pe(this.$slots);
  }
}, qt = gt, $e = {
  ...oe,
  layers: {
    type: String,
    required: !0
  },
  styles: {
    type: String
  },
  format: {
    type: String
  },
  transparent: {
    type: Boolean,
    default: void 0
  },
  version: {
    type: String
  },
  crs: {
    type: Object
  },
  uppercase: {
    type: Boolean,
    default: void 0
  }
}, Ot = (t, o) => {
  const {
    options: e,
    methods: n
  } = Te(t, o);
  return {
    options: L(
      t,
      $e,
      e
    ),
    methods: {
      ...n
    }
  };
}, _t = {
  props: $e,
  setup(t, o) {
    const e = y({}), n = c(g), r = c("addLayer"), { options: s, methods: l } = Ot(t, e);
    return b(async () => {
      const { tileLayer: a, DomEvent: i } = n ? v.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = _(a.wms(t.url, s));
      const u = S(o.attrs);
      i.on(e.value, u), h(l, e.value, t), r({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}, Jt = _t;
export {
  jt as LCircle,
  Pt as LCircleMarker,
  Bt as LControl,
  Tt as LControlAttribution,
  $t as LControlLayers,
  At as LControlScale,
  wt as LControlZoom,
  Gt as LFeatureGroup,
  Mt as LGeoJson,
  It as LGridLayer,
  Nt as LIcon,
  kt as LImageOverlay,
  Dt as LLayerGroup,
  Et as LMap,
  Ht as LMarker,
  Ut as LPolygon,
  zt as LPolyline,
  Ft as LPopup,
  Zt as LRectangle,
  Wt as LTileLayer,
  qt as LTooltip,
  Jt as LWmsTileLayer
};
